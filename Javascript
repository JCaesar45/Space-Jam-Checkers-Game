/* Space Jam Checkers â€” Full JavaScript with fixes for music, save/load, hints, performMove, and buttons */

(() => {
  // ---------- DOM helpers ----------
  const $ = (s) => document.querySelector(s);
  const boardEl = $("#board");
  const menuScreen = $("#menu");
  const gameScreen = $("#game");

  const btnStart = $("#btnStart");
  const btnBackToMenu = $("#btnBackToMenu");
  const btnRestart = $("#btnRestart");
  const btnUndo = $("#btnUndo");
  const btnRematch = $("#btnRematch");
  const btnCloseResult = $("#btnCloseResult");

  const btnTutorialOpen = $("#btnTutorialOpen");
  const btnTutorialClose = $("#btnTutorialClose");
  const tutorialModal = $("#tutorialModal");

  const btnSettingsOpen = $("#btnSettingsOpen");
  const btnSettingsClose = $("#btnSettingsClose");
  const settingsModal = $("#settingsModal");

  const resultsModal = $("#resultsModal");
  const resultTitle = $("#resultTitle");
  const resultBody = $("#resultBody");

  const modeSelect = $("#modeSelect");
  const firstMover = $("#firstMover");
  const moveLogEl = $("#moveLog");
  const turnLabel = $("#turnLabel");

  const toggleSfx = $("#toggleSfx");
  const toggleMusic = $("#toggleMusic");
  const toggleHints = $("#toggleHints");
  const musicVol = $("#musicVol");
  const sfxVol = $("#sfxVol");
  const boardSizeRange = $("#boardSizeRange");

  const btnSave = $("#btnSave");
  const btnLoad = $("#btnLoad");

  const timerEl = $("#timer");
  const turnTimerInput = $("#turnTimerInput");

  const toonScoreEl = $("#toonScore");
  const monstarsScoreEl = $("#monstarsScore");
  const toonKingsEl = $("#toonKings");
  const monstarsKingsEl = $("#monstarsKings");

  // ---------- Background Music ----------
  const musicAudio = new Audio(
    "https://kappa.vgmsite.com/soundtracks/looney-tunes-basketball-1995-snes/gbmxvtli/04.%20Basketball%20Game%201%20%28Part%201%29.mp3"
  );
  musicAudio.loop = true;
  musicAudio.volume = parseFloat(musicVol.value);

  function playMusic() {
    if (toggleMusic.checked) musicAudio.play();
  }
  function stopMusic() {
    musicAudio.pause();
  }

  toggleMusic.addEventListener("change", () => {
    toggleMusic.checked ? playMusic() : stopMusic();
  });
  musicVol.addEventListener("input", () => {
    musicAudio.volume = parseFloat(musicVol.value);
  });

  // ---------- Game constants ----------
  const SIZE = 8;
  const DARK = (r, c) => (r + c) % 2 === 1;
  const SIDES = { TOON: "toon", MON: "monstars" };

  // ---------- State ----------
  const State = {
    board: null,
    turn: SIDES.TOON,
    selected: null,
    forcedChain: null,
    mode: "pvp",
    timerPerTurn: 0,
    timerRemaining: 0,
    timerHandle: null,
    history: [],
    scores: { toon: 0, monstars: 0 }
  };

  // ---------- Helpers ----------
  const cloneBoard = (b) =>
    b.map((row) => row.map((p) => (p ? { ...p } : null)));
  const inBounds = (r, c) => r >= 0 && r < SIZE && c >= 0 && c < SIZE;

  function initialBoard() {
    const b = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));
    for (let r = 0; r < 3; r++)
      for (let c = 0; c < SIZE; c++)
        if (DARK(r, c)) b[r][c] = { side: SIDES.MON, king: false };
    for (let r = SIZE - 3; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++)
        if (DARK(r, c)) b[r][c] = { side: SIDES.TOON, king: false };
    return b;
  }

  // ---------- Render ----------
  function renderBoard() {
    boardEl.innerHTML = "";
    boardEl.style.width = `min(${boardSizeRange.value}vw, ${boardSizeRange.value}vh)`;
    for (let r = 0; r < SIZE; r++) {
      for (let c = 0; c < SIZE; c++) {
        const sq = document.createElement("div");
        sq.className =
          "square " + (DARK(r, c) ? "square--dark" : "square--light");
        sq.dataset.r = r;
        sq.dataset.c = c;
        if (DARK(r, c)) sq.addEventListener("click", onSquareClick);
        const piece = State.board[r][c];
        if (piece) {
          const el = document.createElement("div");
          el.className =
            "piece " +
            (piece.side === SIDES.TOON ? "piece--toon" : "piece--monstars") +
            (piece.king ? " piece--king" : "");
          el.dataset.r = r;
          el.dataset.c = c;
          if (
            (State.turn === piece.side && !State.forcedChain) ||
            (State.forcedChain &&
              State.forcedChain.r === r &&
              State.forcedChain.c === c)
          ) {
            el.addEventListener("click", onPieceClick);
            if (State.forcedChain) el.classList.add("piece--selected");
          }
          sq.appendChild(el);
        }
        boardEl.appendChild(sq);
      }
    }
    if (toggleHints.checked) highlightTargets();
    updateHUD();
  }

  function updateHUD() {
    const kings = countKings(State.board);
    toonKingsEl.textContent = kings.toon;
    monstarsKingsEl.textContent = kings.monstars;
    turnLabel.textContent =
      (State.turn === SIDES.TOON ? "Toon Squad" : "Monstars") + " to move";
    toonScoreEl.textContent = State.scores.toon;
    monstarsScoreEl.textContent = State.scores.monstars;
  }

  function countKings(board) {
    let t = 0,
      m = 0;
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++) {
        const p = board[r][c];
        if (!p || !p.king) continue;
        p.side === SIDES.TOON ? t++ : m++;
      }
    return { toon: t, monstars: m };
  }

  // ---------- Moves ----------
  const DIRS = {
    toon: [
      [-1, -1],
      [-1, 1]
    ],
    monstars: [
      [1, -1],
      [1, 1]
    ],
    king: [
      [-1, -1],
      [-1, 1],
      [1, -1],
      [1, 1]
    ]
  };

  function pieceMoves(board, r, c) {
    const p = board[r][c];
    if (!p) return { moves: [], captures: [] };
    const dirs = p.king
      ? DIRS.king
      : p.side === SIDES.TOON
      ? DIRS.toon
      : DIRS.monstars;
    const moves = [], captures = [];
    for (const [dr, dc] of dirs) {
      const nr = r + dr,
        nc = c + dc;
      if (inBounds(nr, nc) && !board[nr][nc])
        moves.push({ from: [r, c], to: [nr, nc] });
    }
    for (const [dr, dc] of DIRS.king) {
      const canDir =
        p.king ||
        (p.side === SIDES.TOON && dr === -1) ||
        (p.side === SIDES.MON && dr === 1);
      if (!canDir) continue;
      const mr = r + dr,
        mc = c + dc;
      const jr = r + 2 * dr,
        jc = c + 2 * dc;
      if (
        inBounds(jr, jc) &&
        inBounds(mr, mc) &&
        board[mr][mc] &&
        board[mr][mc].side !== p.side &&
        !board[jr][jc]
      ) {
        captures.push({ from: [r, c], over: [mr, mc], to: [jr, jc] });
      }
    }
    return { moves, captures };
  }

  function allMoves(board, side) {
    const caps = [], quiet = [];
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++) {
        const p = board[r][c];
        if (!p || p.side !== side) continue;
        const { moves, captures } = pieceMoves(board, r, c);
        if (captures.length) caps.push(...captures);
        else quiet.push(...moves);
      }
    return { captures: caps, moves: quiet };
  }

  function applyMove(board, mv) {
    const nb = cloneBoard(board);
    const [fr, fc] = mv.from,
      [tr, tc] = mv.to;
    const p = { ...nb[fr][fc] };
    nb[fr][fc] = null;
    nb[tr][tc] = p;

    let captured = null;
    if (mv.over) {
      const [or, oc] = mv.over;
      captured = { ...nb[or][oc] };
      nb[or][oc] = null;
    }

    if (!p.king) {
      if (p.side === SIDES.TOON && tr === 0) {
        p.king = true;
        mv.crowned = true;
      }
      if (p.side === SIDES.MON && tr === SIZE - 1) {
        p.king = true;
        mv.crowned = true;
      }
    }

    return { board: nb, captured };
  }

  // ---------- Perform Move ----------
  function performMove(mv, isAuto = false) {
    // Save current state for undo
    State.history.push({
      board: cloneBoard(State.board),
      turn: State.turn,
      selected: State.selected,
      forcedChain: State.forcedChain
    });

    const { board: newBoard, captured } = applyMove(State.board, mv);
    State.board = newBoard;

    // Update scores
    if (captured) {
      State.scores[captured.side === SIDES.TOON ? "monstars" : "toon"]++;
    }

    // Check for multi-capture sequence
    if (mv.over) {
      const further = pieceMoves(State.board, mv.to[0], mv.to[1]).captures;
      if (further.length) {
        State.forcedChain = { r: mv.to[0], c: mv.to[1] };
        State.selected = { r: mv.to[0], c: mv.to[1] };
        renderBoard();
        return; // keep turn
      }
    }

    // Reset chain and selected
    State.forcedChain = null;
    State.selected = null;

    // Log move
    logMove(mv);

    // Check for game over
    const movesLeft = allMoves(
      State.board,
      State.turn === SIDES.TOON ? SIDES.MON : SIDES.TOON
    );
    if (movesLeft.captures.length === 0 && movesLeft.moves.length === 0) {
      endGame(State.turn, "No moves left");
      return;
    }

    // Switch turn
    switchTurn();
  }

  // ---------- Timer ----------
  function startTimer() {
    clearInterval(State.timerHandle);
    const secs = parseInt(turnTimerInput.value || "0", 10);
    State.timerPerTurn = secs;
    if (!secs) {
      timerEl.classList.add("hidden");
      return;
    }
    State.timerRemaining = secs;
    timerEl.classList.remove("hidden");
    timerEl.textContent = String(State.timerRemaining).padStart(2, "0");
    State.timerHandle = setInterval(() => {
      State.timerRemaining--;
      timerEl.textContent = String(State.timerRemaining).padStart(2, "0");
      if (toggleSfx.checked) {
        /* placeholder for tick SFX */
      }
      if (State.timerRemaining <= 0) {
        clearInterval(State.timerHandle);
        const { captures, moves } = allMoves(State.board, State.turn);
        const options = captures.length ? captures : moves;
        if (options.length)
          performMove(
            options[Math.floor(Math.random() * options.length)],
            true
          );
        else
          endGame(
            State.turn === SIDES.TOON ? SIDES.MON : SIDES.TOON,
            "Time ran out"
          );
      }
    }, 1000);
  }

  function switchTurn() {
    State.turn = State.turn === SIDES.TOON ? SIDES.MON : SIDES.TOON;
    State.selected = null;
    State.forcedChain = null;
    renderBoard();
    startTimer();

    // Trigger AI move if needed
    if (State.mode.startsWith("ai") && State.turn === SIDES.MON)
      setTimeout(aiMove, 300);
  }

  // ---------- UI ----------
  function onPieceClick(e) {
    e.stopPropagation();
    const r = parseInt(e.currentTarget.dataset.r, 10);
    const c = parseInt(e.currentTarget.dataset.c, 10);
    State.selected = { r, c };
    renderBoard();
  }

  function onSquareClick(e) {
    const r = parseInt(e.currentTarget.dataset.r, 10);
    const c = parseInt(e.currentTarget.dataset.c, 10);
    if (!State.selected) return;
    const { r: sr, c: sc } = State.selected;
    const moves = legalMovesForSelected(sr, sc);
    const mv = moves.find((m) => m.to[0] === r && m.to[1] === c);
    if (!mv) return;
    performMove(mv);
  }

  function legalMovesForSelected(r, c) {
    const p = State.board[r][c];
    if (!p) return [];
    const all = allMoves(State.board, State.turn);
    const { moves, captures } = pieceMoves(State.board, r, c);
    if (captures.length || all.captures.length) return captures;
    return moves;
  }

  function highlightTargets() {
    document
      .querySelectorAll(".square--target")
      .forEach((el) => el.classList.remove("square--target"));
    if (!State.selected) return;
    const { r, c } = State.selected;
    const legal = legalMovesForSelected(r, c);
    legal.forEach((mv) => {
      const sq = document.querySelector(
        `.square[data-r="${mv.to[0]}"][data-c="${mv.to[1]}"]`
      );
      if (sq) sq.classList.add("square--target");
    });
  }

  function algebra([r, c]) {
    return String.fromCharCode(97 + c) + (SIZE - r);
  }
  function logMove(mv) {
    const li = document.createElement("li");
    li.textContent =
      (State.turn === SIDES.TOON ? "Toon" : "Mon") +
      ": " +
      (mv.over
        ? `${algebra(mv.from)} x ${algebra(mv.to)}`
        : `${algebra(mv.from)} - ${algebra(mv.to)}`) +
      (mv.crowned ? " (K)" : "");
    moveLogEl.appendChild(li);
    moveLogEl.scrollTop = moveLogEl.scrollHeight;
  }

  // ---------- Save / Load ----------
  function saveGame() {
    const payload = {
      board: cloneBoard(State.board),
      turn: State.turn,
      scores: { ...State.scores },
      mode: State.mode,
      timerPerTurn: parseInt(turnTimerInput.value || "0", 10)
    };
    localStorage.setItem("sj-checkers-save", JSON.stringify(payload));
  }

  function loadGame() {
    const raw = localStorage.getItem("sj-checkers-save");
    if (!raw) return;
    const data = JSON.parse(raw);
    State.board = data.board.map((row) =>
      row.map((p) => (p ? { ...p } : null))
    );
    State.turn = data.turn;
    State.scores = data.scores || { toon: 0, monstars: 0 };
    State.mode = data.mode || "pvp";
    turnTimerInput.value = data.timerPerTurn || 0;
    moveLogEl.innerHTML = "";
    State.history = [];
    State.selected = null;
    State.forcedChain = null;
    renderBoard();
    startTimer();
  }

  // ---------- AI ----------
  // Placeholder for computeBestMove (replace with your minimax implementation)
  async function computeBestMove(board, side, depth) {
    const moves = Object.values(allMoves(board, side)).flat();
    if (moves.length === 0) return null;
    // For testing, pick a random move
    return moves[Math.floor(Math.random() * moves.length)];
  }

  function aiMove() {
    const modeVal = State.mode;
    const depth =
      modeVal === "ai-easy" ? 1 :
      modeVal === "ai-medium" ? 3 :
      modeVal === "ai-hard" ? 5 :
      5; // fallback

    console.log("AI move: Mode:", modeVal, "Depth:", depth);

    computeBestMove(State.board, SIDES.MON, depth).then((mv) => {
      if (!mv) {
        endGame(SIDES.TOON, "AI has no moves");
        return;
      }
      performMove(mv);
    });
  }

  // ---------- End Game ----------
  function endGame(winnerSide, reason) {
    clearInterval(State.timerHandle);
    stopMusic();
    resultTitle.textContent =
      winnerSide === SIDES.TOON ? "Toon Squad Wins!" : "Monstars Win!";
    resultBody.textContent = reason || "";
    resultsModal.showModal();
  }

  // ---------- Controls ----------
  btnStart.addEventListener("click", () => {
    State.mode = modeSelect.value;
    console.log("Game start mode:", State.mode);
    State.board = initialBoard();
    State.turn = firstMover.value === "toon" ? SIDES.TOON : SIDES.MON;
    State.selected = null;
    State.forcedChain = null;
    State.history = [];
    moveLogEl.innerHTML = "";
    showGame();
  });

  function showGame() {
    menuScreen.classList.remove("screen--active");
    gameScreen.classList.add("screen--active");
    renderBoard();
    startTimer();

    // If AI mode and it's Monstars turn, trigger AI move
    if (State.mode.startsWith("ai") && State.turn === SIDES.MON)
      setTimeout(aiMove, 400);
  }

  // Buttons for navigating back, restart, undo
  btnBackToMenu.addEventListener("click", () => {
    clearInterval(State.timerHandle);
    stopMusic();
    gameScreen.classList.remove("screen--active");
    menuScreen.classList.add("screen--active");
  });

  btnRestart.addEventListener("click", () => {
    State.board = initialBoard();
    State.selected = null;
    State.forcedChain = null;
    State.history = [];
    moveLogEl.innerHTML = "";
    renderBoard();
    startTimer();
  });

  btnUndo.addEventListener("click", () => {
    if (State.mode.startsWith("ai") && State.turn === SIDES.MON) return;
    const last = State.history.pop();
    if (!last) return;
    State.board = last.board;
    State.turn = last.turn;
    State.selected = last.selected;
    State.forcedChain = last.forcedChain;
    renderBoard();
  });

  // Hints toggle
  toggleHints.addEventListener("change", () => renderBoard());

  // Tutorial modal
  btnTutorialOpen.addEventListener("click", () => tutorialModal.showModal());
  btnTutorialClose.addEventListener("click", () => tutorialModal.close());

  // Settings modal
  btnSettingsOpen.addEventListener("click", () => settingsModal.showModal());
  btnSettingsClose.addEventListener("click", () => settingsModal.close());

  // Save / Load buttons
  btnSave.addEventListener("click", saveGame);
  btnLoad.addEventListener("click", loadGame);

  // Board size adjustment
  boardSizeRange.addEventListener("input", () => renderBoard());

  // ---------- Init ----------
  (function init() {
    State.board = initialBoard();
    renderBoard();
  })();

  // ---------- Additional event handlers for modal buttons (Rematch & Close) ----------
  document
    .querySelector("#btnRematch")
    .addEventListener("click", () => {
      State.board = initialBoard();
      State.selected = null;
      State.forcedChain = null;
      State.history = [];
      moveLogEl.innerHTML = "";
      renderBoard();
      startTimer();
      resultsModal.close();
    });

  document
    .querySelector("#btnCloseResult")
    .addEventListener("click", () => {
      resultsModal.close();
    });
})();
