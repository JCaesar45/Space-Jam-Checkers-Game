/* Space Jam Checkers â€” JavaScript
   - American checkers with mandatory jumps & multi-captures
   - PvP + AI (Easy / Medium / Hard via depth-limited minimax)
   - Click-to-move, hints, undo, restart, save/load, per-turn timer
   - WebAudio SFX + optional simple music loop
*/

(() => {
  // ---------- DOM helpers ----------
  const $ = (s) => document.querySelector(s);
  const boardEl = $("#board");
  const menuScreen = $("#menu");
  const gameScreen = $("#game");

  const btnStart = $("#btnStart");
  const btnBackToMenu = $("#btnBackToMenu");
  const btnRestart = $("#btnRestart");
  const btnUndo = $("#btnUndo");

  const btnTutorialOpen = $("#btnTutorialOpen");
  const btnTutorialClose = $("#btnTutorialClose");
  const tutorialModal = $("#tutorialModal");

  const btnSettingsOpen = $("#btnSettingsOpen");
  const btnSettingsClose = $("#btnSettingsClose");
  const settingsModal = $("#settingsModal");

  const resultsModal = $("#resultsModal");
  const btnRematch = $("#btnRematch");
  const btnCloseResult = $("#btnCloseResult");
  const resultTitle = $("#resultTitle");
  const resultBody = $("#resultBody");

  const modeSelect = $("#modeSelect");
  const firstMover = $("#firstMover");
  const moveLogEl = $("#moveLog");
  const turnLabel = $("#turnLabel");

  const toggleSfx = $("#toggleSfx");
  const toggleMusic = $("#toggleMusic");
  const toggleHints = $("#toggleHints");
  const musicVol = $("#musicVol");
  const sfxVol = $("#sfxVol");
  const boardSizeRange = $("#boardSizeRange");

  const btnSave = $("#btnSave");
  const btnLoad = $("#btnLoad");

  const timerEl = $("#timer");
  const turnTimerInput = $("#turnTimerInput");

  const toonScoreEl = $("#toonScore");
  const monstarsScoreEl = $("#monstarsScore");
  const toonKingsEl = $("#toonKings");
  const monstarsKingsEl = $("#monstarsKings");

  // ---------- Audio (purely synthesized, no assets) ----------
  const AudioSys = (() => {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const master = ctx.createGain();
    master.gain.value = 0.9;
    master.connect(ctx.destination);

    const sfx = ctx.createGain();
    sfx.gain.value = parseFloat(sfxVol.value);
    sfx.connect(master);
    const music = ctx.createGain();
    music.gain.value = parseFloat(musicVol.value);
    music.connect(master);

    function beep({ freq = 440, dur = 0.08, type = "triangle", vol = 0.7 }) {
      if (!toggleSfx.checked) return;
      const osc = ctx.createOscillator();
      const g = ctx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      g.gain.value = sfx.gain.value * vol;
      osc.connect(g).connect(sfx);
      const t = ctx.currentTime;
      osc.start(t);
      osc.stop(t + dur);
      g.gain.setValueAtTime(g.gain.value, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    }

    // Simple 4-bar loop (original notes)
    let playing = false,
      loopId = null;
    function startMusic() {
      if (playing || !toggleMusic.checked) return;
      playing = true;
      const tempo = 96,
        beat = 60 / tempo;
      const seq = [330, 392, 440, 392, 330, 392, 494, 523];
      const schedule = () => {
        const now = ctx.currentTime + 0.1;
        for (let m = 0; m < 4; m++) {
          seq.forEach((f, i) => {
            const osc = ctx.createOscillator();
            const g = ctx.createGain();
            osc.type = "sawtooth";
            osc.frequency.value = f;
            g.gain.value = music.gain.value * 0.25;
            const st = now + (m * seq.length + i) * beat;
            osc.connect(g).connect(music);
            osc.start(st);
            g.gain.setValueAtTime(g.gain.value, st);
            g.gain.exponentialRampToValueAtTime(0.0001, st + beat * 0.45);
            osc.stop(st + beat * 0.45);
          });
        }
      };
      schedule();
      loopId = setInterval(schedule, 4 * seq.length * beat * 1000);
    }
    function stopMusic() {
      playing = false;
      if (loopId) clearInterval(loopId);
      loopId = null;
    }

    // UI bindings
    musicVol.addEventListener(
      "input",
      () => (music.gain.value = parseFloat(musicVol.value))
    );
    sfxVol.addEventListener(
      "input",
      () => (sfx.gain.value = parseFloat(sfxVol.value))
    );
    toggleMusic.addEventListener("change", () =>
      toggleMusic.checked ? startMusic() : stopMusic()
    );
    window.addEventListener("pointerdown", () => ctx.resume(), { once: true });

    return {
      move: () => beep({ freq: 460, dur: 0.06, type: "triangle", vol: 0.8 }),
      capture: () => beep({ freq: 200, dur: 0.1, type: "square", vol: 1.0 }),
      crown: () => beep({ freq: 880, dur: 0.14, type: "sine", vol: 0.9 }),
      win: () => {
        [523, 659, 784].forEach((f, i) =>
          setTimeout(
            () => beep({ freq: f, dur: 0.12, type: "sine", vol: 1 }),
            i * 120
          )
        );
      },
      tick: () => beep({ freq: 700, dur: 0.035, type: "square", vol: 0.5 }),
      startMusic,
      stopMusic
    };
  })();

  // ---------- Game constants ----------
  const SIZE = 8;
  const DARK = (r, c) => (r + c) % 2 === 1;

  // Pieces: { side:'toon'|'monstars', king:boolean }
  const SIDES = { TOON: "toon", MON: "monstars" };

  // ---------- State ----------
  const State = {
    board: null, // 8x8, null or piece
    turn: SIDES.TOON,
    selected: null, // {r,c} or null
    forcedChain: null, // piece index that must continue multi-capture
    mode: "pvp", // pvp | ai-easy | ai-medium | ai-hard
    timerPerTurn: 0, // seconds (0 = off)
    timerRemaining: 0,
    timerHandle: null,
    history: [], // stack of prior states for undo
    scores: { toon: 0, monstars: 0 }
  };

  // ---------- Helpers ----------
  const cloneBoard = (b) =>
    b.map((row) => row.map((p) => (p ? { ...p } : null)));
  const inBounds = (r, c) => r >= 0 && r < SIZE && c >= 0 && c < SIZE;

  function initialBoard() {
    const b = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));
    for (let r = 0; r < 3; r++) {
      for (let c = 0; c < SIZE; c++) {
        if (DARK(r, c)) b[r][c] = { side: SIDES.MON, king: false };
      }
    }
    for (let r = SIZE - 3; r < SIZE; r++) {
      for (let c = 0; c < SIZE; c++) {
        if (DARK(r, c)) b[r][c] = { side: SIDES.TOON, king: false };
      }
    }
    return b;
  }

  // Render
  function renderBoard() {
    boardEl.innerHTML = "";
    boardEl.style.width = `min(${boardSizeRange.value}vw, ${boardSizeRange.value}vh)`;
    for (let r = 0; r < SIZE; r++) {
      for (let c = 0; c < SIZE; c++) {
        const sq = document.createElement("div");
        sq.className =
          "square " + (DARK(r, c) ? "square--dark" : "square--light");
        sq.dataset.r = r;
        sq.dataset.c = c;
        if (DARK(r, c)) sq.addEventListener("click", onSquareClick);
        const piece = State.board[r][c];
        if (piece) {
          const el = document.createElement("div");
          el.className =
            "piece " +
            (piece.side === SIDES.TOON ? "piece--toon" : "piece--monstars") +
            (piece.king ? " piece--king" : "");
          el.dataset.r = r;
          el.dataset.c = c;
          if (State.turn === piece.side && !State.forcedChain) {
            el.addEventListener("click", onPieceClick);
          } else if (
            State.forcedChain &&
            State.forcedChain.r === r &&
            State.forcedChain.c === c
          ) {
            el.addEventListener("click", onPieceClick);
            el.classList.add("piece--selected");
          }
          sq.appendChild(el);
        }
        boardEl.appendChild(sq);
      }
    }
    if (toggleHints.checked) highlightTargets();
    updateHUD();
  }

  function updateHUD() {
    const kings = countKings(State.board);
    $("#toonKings").textContent = kings.toon;
    $("#monstarsKings").textContent = kings.monstars;
    $("#turnLabel").textContent =
      (State.turn === SIDES.TOON ? "Toon Squad" : "Monstars") + " to move";
    toonScoreEl.textContent = State.scores.toon;
    monstarsScoreEl.textContent = State.scores.monstars;
  }

  function countKings(board) {
    let t = 0,
      m = 0;
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++) {
        const p = board[r][c];
        if (!p || !p.king) continue;
        if (p.side === SIDES.TOON) t++;
        else m++;
      }
    return { toon: t, monstars: m };
  }

  // ---------- Move generation ----------
  const DIRS = {
    toon: [
      [-1, -1],
      [-1, 1]
    ],
    monstars: [
      [1, -1],
      [1, 1]
    ],
    king: [
      [-1, -1],
      [-1, 1],
      [1, -1],
      [1, 1]
    ]
  };

  function pieceMoves(board, r, c) {
    const p = board[r][c];
    if (!p) return { moves: [], captures: [] };
    const dirs = p.king
      ? DIRS.king
      : p.side === SIDES.TOON
      ? DIRS.toon
      : DIRS.monstars;
    const moves = [],
      captures = [];
    // simple moves
    for (const [dr, dc] of dirs) {
      const nr = r + dr,
        nc = c + dc;
      if (inBounds(nr, nc) && !board[nr][nc])
        moves.push({ from: [r, c], to: [nr, nc] });
    }
    // captures
    for (const [dr, dc] of DIRS.king) {
      // capture can be backwards for kings; for men only forward? In American checkers, men capture forward only. We'll respect that:
      const canDir = p.king
        ? true
        : (p.side === SIDES.TOON && dr === -1) ||
          (p.side === SIDES.MON && dr === 1);
      if (!canDir) continue;
      const mr = r + dr,
        mc = c + dc,
        jr = r + 2 * dr,
        jc = c + 2 * dc;
      if (
        inBounds(jr, jc) &&
        board[mr][mc] &&
        board[mr][mc].side !== p.side &&
        !board[jr][jc]
      ) {
        captures.push({ from: [r, c], over: [mr, mc], to: [jr, jc] });
      }
    }
    return { moves, captures };
  }

  function allMoves(board, side) {
    const caps = [],
      quiet = [];
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++) {
        const p = board[r][c];
        if (!p || p.side !== side) continue;
        const { moves, captures } = pieceMoves(board, r, c);
        if (captures.length) caps.push(...captures);
        else quiet.push(...moves);
      }
    return { captures: caps, moves: quiet };
  }

  // Apply / Undo
  function applyMove(board, mv) {
    const nb = cloneBoard(board);
    const [fr, fc] = mv.from,
      [tr, tc] = mv.to;
    const p = { ...nb[fr][fc] };
    nb[fr][fc] = null;
    nb[tr][tc] = p;
    let captured = null;
    if (mv.over) {
      const [or, oc] = mv.over;
      captured = { ...nb[or][oc] };
      nb[or][oc] = null;
    }
    // crown
    if (!p.king) {
      if (p.side === SIDES.TOON && tr === 0) {
        p.king = true;
        nb[tr][tc] = p;
        mv.crowned = true;
      }
      if (p.side === SIDES.MON && tr === SIZE - 1) {
        p.king = true;
        nb[tr][tc] = p;
        mv.crowned = true;
      }
    }
    return { board: nb, captured };
  }

  // ---------- Turn / Timer ----------
  function startTimer() {
    clearInterval(State.timerHandle);
    const secs = parseInt(turnTimerInput.value || "0", 10);
    State.timerPerTurn = secs;
    if (!secs) {
      timerEl.classList.add("hidden");
      return;
    }
    State.timerRemaining = secs;
    timerEl.classList.remove("hidden");
    timerEl.textContent = String(State.timerRemaining).padStart(2, "0");
    State.timerHandle = setInterval(() => {
      State.timerRemaining--;
      timerEl.textContent = String(State.timerRemaining).padStart(2, "0");
      AudioSys.tick();
      if (State.timerRemaining <= 0) {
        clearInterval(State.timerHandle);
        // Auto-pass/lose: if AI side, force AI move; if player side, forfeit turn by random legal move
        const { captures, moves } = allMoves(State.board, State.turn);
        const options = captures.length ? captures : moves;
        if (options.length) {
          const mv = options[Math.floor(Math.random() * options.length)];
          performMove(mv, true);
        } else {
          endGame(
            State.turn === SIDES.TOON ? SIDES.MON : SIDES.TOON,
            "Time ran out"
          );
        }
      }
    }, 1000);
  }

  function switchTurn() {
    State.turn = State.turn === SIDES.TOON ? SIDES.MON : SIDES.TOON;
    State.selected = null;
    State.forcedChain = null;
    renderBoard();
    startTimer();
    // AI turn?
    if (State.mode.startsWith("ai") && State.turn === SIDES.MON) {
      setTimeout(aiMove, 300);
    }
  }

  // ---------- UI interactions ----------
  function onPieceClick(e) {
    e.stopPropagation();
    const r = parseInt(e.currentTarget.dataset.r, 10);
    const c = parseInt(e.currentTarget.dataset.c, 10);
    // if we are in forced chain, only this piece is allowed (already ensured)
    State.selected = { r, c };
    renderBoard();
    // re-apply selection highlight
    const el = [...document.querySelectorAll(".piece")].find(
      (p) => +p.dataset.r === r && +p.dataset.c === c
    );
    if (el) el.classList.add("piece--selected");
    if (toggleHints.checked) highlightTargets();
  }

  function onSquareClick(e) {
    const r = parseInt(e.currentTarget.dataset.r, 10);
    const c = parseInt(e.currentTarget.dataset.c, 10);
    if (!State.selected) return;

    const { r: sr, c: sc } = State.selected;
    const moves = legalMovesForSelected(sr, sc);
    const mv = moves.find((m) => m.to[0] === r && m.to[1] === c);
    if (!mv) return;

    performMove(mv);
  }

  function legalMovesForSelected(r, c) {
    const p = State.board[r][c];
    if (!p) return [];
    // Mandatory capture rule
    const all = allMoves(State.board, State.turn);
    const { moves, captures } = pieceMoves(State.board, r, c);
    if (captures.length || all.captures.length) return captures;
    return moves;
  }

  function highlightTargets() {
    // Clear old
    document
      .querySelectorAll(".square--target")
      .forEach((el) => el.classList.remove("square--target"));
    if (!State.selected) return;
    const { r, c } = State.selected;
    const legal = legalMovesForSelected(r, c);
    legal.forEach((mv) => {
      const [tr, tc] = mv.to;
      const sel = `.square[data-r="${tr}"][data-c="${tc}"]`;
      const sq = document.querySelector(sel);
      if (sq) sq.classList.add("square--target");
    });
  }

  // ---------- Logging ----------
  function algebra([r, c]) {
    return String.fromCharCode(97 + c) + (SIZE - r);
  }
  function logMove(mv) {
    const li = document.createElement("li");
    const text = mv.over
      ? `${algebra(mv.from)} x ${algebra(mv.to)}${mv.crowned ? " (K)" : ""}`
      : `${algebra(mv.from)} - ${algebra(mv.to)}${mv.crowned ? " (K)" : ""}`;
    li.textContent = (State.turn === SIDES.TOON ? "Toon" : "Mon") + ": " + text;
    moveLogEl.appendChild(li);
    moveLogEl.scrollTop = moveLogEl.scrollHeight;
  }

  // ---------- Perform move & chain ----------
  function pushHistory() {
    State.history.push({
      board: cloneBoard(State.board),
      turn: State.turn,
      selected: State.selected ? { ...State.selected } : null,
      forcedChain: State.forcedChain ? { ...State.forcedChain } : null
    });
    if (State.history.length > 200) State.history.shift();
  }

  function performMove(mv, silent = false) {
    pushHistory();
    const res = applyMove(State.board, mv);
    State.board = res.board;

    if (!silent) {
      logMove(mv);
      if (mv.over) AudioSys.capture();
      else AudioSys.move();
      if (mv.crowned) AudioSys.crown();
    }

    // Multi-capture check if we captured and not crowned just now (American checkers: if crowned during a capturing move, the move ends; no further captures)
    if (mv.over && !mv.crowned) {
      const [tr, tc] = mv.to;
      const more = pieceMoves(State.board, tr, tc).captures;
      if (more.length) {
        State.forcedChain = { r: tr, c: tc };
        State.selected = { r: tr, c: tc };
        renderBoard();
        return; // same player's turn continues
      }
    }

    // Check win
    const opp = State.turn === SIDES.TOON ? SIDES.MON : SIDES.TOON;
    const oppMoves = allMoves(State.board, opp);
    const oppHasPieces = State.board.flat().some((p) => p && p.side === opp);
    if (
      !oppHasPieces ||
      (oppMoves.captures.length === 0 && oppMoves.moves.length === 0)
    ) {
      endGame(
        State.turn,
        oppHasPieces
          ? "Opponent has no legal moves"
          : "All opponent pieces captured"
      );
      return;
    }

    // Switch turn
    switchTurn();
  }

  function endGame(winner, reason) {
    if (winner === SIDES.TOON) State.scores.toon++;
    else State.scores.monstars++;
    renderBoard();
    clearInterval(State.timerHandle);
    resultTitle.textContent = `${
      winner === SIDES.TOON ? "Toon Squad" : "Monstars"
    } win!`;
    resultBody.textContent = reason || "GG!";
    resultsModal.showModal();
    AudioSys.win();
  }

  // ---------- Save / Load ----------
  function saveGame() {
    const payload = {
      board: State.board,
      turn: State.turn,
      scores: State.scores,
      mode: State.mode,
      timerPerTurn: parseInt(turnTimerInput.value || "0", 10)
    };
    localStorage.setItem("sj-checkers-save", JSON.stringify(payload));
  }

  function loadGame() {
    const raw = localStorage.getItem("sj-checkers-save");
    if (!raw) return;
    const data = JSON.parse(raw);
    State.board = data.board;
    State.turn = data.turn;
    State.scores = data.scores || { toon: 0, monstars: 0 };
    State.mode = data.mode || "pvp";
    turnTimerInput.value = data.timerPerTurn || 0;
    moveLogEl.innerHTML = "";
    State.history = [];
    State.selected = null;
    State.forcedChain = null;
    showGame();
  }

  // ---------- AI ----------
  function aiMove() {
    // Difficulty mapping
    const depth =
      State.mode === "ai-easy" ? 1 : State.mode === "ai-medium" ? 3 : 5;
    const mv = computeBestMove(State.board, SIDES.MON, depth);
    if (!mv) {
      endGame(SIDES.TOON, "AI has no moves");
      return;
    }
    performMove(mv);
  }

  function evaluate(board) {
    // Simple heuristic: men=1, king=1.5 + mobility
    let score = 0,
      tm = 0,
      mm = 0;
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++) {
        const p = board[r][c];
        if (!p) continue;
        const val = p.king ? 1.5 : 1;
        if (p.side === SIDES.MON) score += val;
        else score -= val;
        if (p.side === SIDES.MON) mm++;
        else tm++;
      }
    const mob = allMoves(board, SIDES.MON);
    const mob2 = allMoves(board, SIDES.TOON);
    score += 0.05 * (mob.moves.length + 2 * mob.captures.length);
    score -= 0.05 * (mob2.moves.length + 2 * mob2.captures.length);
    // prefer center
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++) {
        const p = board[r][c];
        if (!p) continue;
        const center = 3.5 - Math.abs(r - 3.5) + (3.5 - Math.abs(c - 3.5)); // 0..7
        const w = 0.01 * center * (p.side === SIDES.MON ? 1 : -1);
        score += w;
      }
    return score;
  }

  function computeBestMove(board, side, depth) {
    const maximizing = side === SIDES.MON;
    const alphaBeta = (b, d, a, beta, turnSide) => {
      // terminal?
      const moves = allMoves(b, turnSide);
      const noMoves = moves.captures.length === 0 && moves.moves.length === 0;
      if (d === 0 || noMoves) return [evaluate(b), null];

      const seq = moves.captures.length ? moves.captures : moves.moves; // enforce capture
      let bestMove = null;

      if (turnSide === SIDES.MON) {
        // maximizing
        let val = -Infinity;
        for (const mv of seq) {
          const { board: nb } = applyMove(b, mv);
          // multi-capture continuation if possible and not crowned
          let v;
          if (mv.over && !mv.crowned) {
            const [tr, tc] = mv.to;
            const more = pieceMoves(nb, tr, tc).captures;
            if (more.length) {
              v = alphaBetaChain(nb, d, a, beta, SIDES.MON, tr, tc); // same depth
            } else {
              v = alphaBeta(nb, d - 1, a, beta, SIDES.TOON)[0];
            }
          } else {
            v = alphaBeta(nb, d - 1, a, beta, SIDES.TOON)[0];
          }
          if (v > val) {
            val = v;
            bestMove = mv;
          }
          a = Math.max(a, val);
          if (beta <= a) break;
        }
        return [val, bestMove];
      } else {
        // minimizing (Toon)
        let val = Infinity;
        for (const mv of seq) {
          const { board: nb } = applyMove(b, mv);
          let v;
          if (mv.over && !mv.crowned) {
            const [tr, tc] = mv.to;
            const more = pieceMoves(nb, tr, tc).captures;
            if (more.length) {
              v = alphaBetaChain(nb, d, a, beta, SIDES.TOON, tr, tc);
            } else {
              v = alphaBeta(nb, d - 1, a, beta, SIDES.MON)[0];
            }
          } else {
            v = alphaBeta(nb, d - 1, a, beta, SIDES.MON)[0];
          }
          if (v < val) {
            val = v;
            bestMove = mv;
          }
          beta = Math.min(beta, val);
          if (beta <= a) break;
        }
        return [val, bestMove];
      }
    };

    // Handle forced multi-capture within a ply
    const alphaBetaChain = (b, d, a, beta, sideInChain, r, c) => {
      const caps = pieceMoves(b, r, c).captures;
      if (!caps.length)
        return alphaBeta(
          b,
          d - 1,
          a,
          beta,
          sideInChain === SIDES.MON ? SIDES.TOON : SIDES.MON
        )[0];
      if (sideInChain === SIDES.MON) {
        let val = -Infinity;
        for (const mv of caps) {
          const { board: nb } = applyMove(b, mv);
          let v;
          if (mv.over && !mv.crowned) {
            const [tr, tc] = mv.to;
            const more = pieceMoves(nb, tr, tc).captures;
            v = more.length
              ? alphaBetaChain(nb, d, a, beta, sideInChain, tr, tc)
              : alphaBeta(nb, d - 1, a, beta, SIDES.TOON)[0];
          } else {
            v = alphaBeta(nb, d - 1, a, beta, SIDES.TOON)[0];
          }
          val = Math.max(val, v);
          a = Math.max(a, val);
          if (beta <= a) break;
        }
        return val;
      } else {
        let val = Infinity;
        for (const mv of caps) {
          const { board: nb } = applyMove(b, mv);
          let v;
          if (mv.over && !mv.crowned) {
            const [tr, tc] = mv.to;
            const more = pieceMoves(nb, tr, tc).captures;
            v = more.length
              ? alphaBetaChain(nb, d, a, beta, sideInChain, tr, tc)
              : alphaBeta(nb, d - 1, a, beta, SIDES.MON)[0];
          } else {
            v = alphaBeta(nb, d - 1, a, beta, SIDES.MON)[0];
          }
          val = Math.min(val, v);
          beta = Math.min(beta, val);
          if (beta <= a) break;
        }
        return val;
      }
    };

    return alphaBeta(board, depth, -Infinity, Infinity, side)[1];
  }

  // ---------- Controls ----------
  btnStart.addEventListener("click", () => {
    State.mode = modeSelect.value;
    State.board = initialBoard();
    State.turn = firstMover.value === "toon" ? SIDES.TOON : SIDES.MON;
    State.selected = null;
    State.forcedChain = null;
    State.history = [];
    moveLogEl.innerHTML = "";
    showGame();
  });

  function showGame() {
    menuScreen.classList.remove("screen--active");
    gameScreen.classList.add("screen--active");
    renderBoard();
    startTimer();
    if (toggleMusic.checked) AudioSys.startMusic();
    if (State.mode.startsWith("ai") && State.turn === SIDES.MON)
      setTimeout(aiMove, 400);
  }

  btnBackToMenu.addEventListener("click", () => {
    clearInterval(State.timerHandle);
    AudioSys.stopMusic();
    gameScreen.classList.remove("screen--active");
    menuScreen.classList.add("screen--active");
  });

  btnRestart.addEventListener("click", () => {
    State.board = initialBoard();
    State.selected = null;
    State.forcedChain = null;
    State.history = [];
    moveLogEl.innerHTML = "";
    renderBoard();
    startTimer();
  });

  btnUndo.addEventListener("click", () => {
    // Only allowed when not AI's turn
    if (State.mode.startsWith("ai") && State.turn === SIDES.MON) return;
    const last = State.history.pop();
    if (!last) return;
    State.board = last.board;
    State.turn = last.turn;
    State.selected = last.selected;
    State.forcedChain = last.forcedChain;
    renderBoard();
  });

  btnTutorialOpen.addEventListener("click", () => tutorialModal.showModal());
  btnTutorialClose.addEventListener("click", () => tutorialModal.close());

  btnSettingsOpen.addEventListener("click", () => settingsModal.showModal());
  btnSettingsClose.addEventListener("click", () => settingsModal.close());

  btnRematch.addEventListener("click", () => {
    resultsModal.close();
    btnRestart.click();
  });
  btnCloseResult.addEventListener("click", () => resultsModal.close());

  boardSizeRange.addEventListener("input", () => renderBoard());
  toggleHints.addEventListener("change", () => renderBoard());

  btnSave.addEventListener("click", () => saveGame());
  btnLoad.addEventListener("click", () => loadGame());

  // ---------- Build board once (squares only; pieces via render) ----------
  function bootstrapGrid() {
    // CSS grid squares are created in renderBoard with pieces; keep as-is
  }

  // ---------- Init ----------
  (function init() {
    State.board = initialBoard();
    bootstrapGrid();
    renderBoard();
  })();
})();
